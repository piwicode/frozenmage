<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sp_mage_32</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-200</depth>
  <persistent>0</persistent>
  <parentName>obj_entity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_move_init()

// Input variables have to be defined so that an instance 
// create by an alarm can run the end setp without the begin step.
jump_pressed_ctrl = 0;
jump_held_ctrl = 0;
fire_pressed_ctrl = 0;
fire_check_ctrl = 0;
fire_released_ctrl = 0;
x_ctrl = 0;
y_ctrl = 0;

// Units
var PX = 1; var SEC = room_speed;

// Walk configuration.
walk_speed = 2.3;  // maximum horizontal speed reached when walking.
var walk_accel_time = .05 * SEC; // time it takes to reach the 0 speed.
walk_accel = walk_speed / walk_accel_time;
var brake_accel_time = .20 * SEC; // time it takes to reach the max speed.
brake_accel = walk_speed / brake_accel_time ;

push_speed = 1; // constant horizontal speed, when pushing a block.

air_friction = 2;

// Jump settings.
jump_initial_speed = 6; // pixel per frame.
jump_released_speed = 2; // pixel per frame.

// Number of frames the jump initial key press can trigger the jump action.
jump_ctrl_permissiveness = 400; // frames.
// Jump is triggered when non zero, and the character is standing. 
jump_ctrl_countdown = 0;  // frames. 

aim_arrow = instance_create(x, y, obj_aim_arrow)
aim_arrow.visible = false

var step_length_in_px = 90;
const_image_speed_walk = 14 / (step_length_in_px * 2) * walk_speed // frame per tick

image_speed = 0; // No animation by default.


// Override user inputs for test purpose. Set the following vars with instance
// initialization script.
// Name of a script with no argument executed on the mage after input handling.
input_override_script = false; // Set to true in conjunction



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Detect collisions with walls
scr_move();

// Horizontal flip the sprite according to the command.
if (x_ctrl != 0) {
  image_xscale = x_ctrl;
}
// Play the walk animation only when the mage is moving horizontally.
image_speed = const_image_speed_walk * (xs != 0);

// -y_ctrl because vertical axis is inverted between atan and the screen.
// use image_scale to remember the current facing position. 
var x_fire = (bbox_right + bbox_left) * .5;
var y_fire = (bbox_top + bbox_bottom) * .5;
if (x_ctrl == 0 &amp;&amp; y_ctrl == 0) {
  var aim_direction = radtodeg(arctan2(-y_ctrl, image_xscale));
} else {
  var aim_direction = radtodeg(arctan2(-y_ctrl, x_ctrl));
}
aim_arrow.visible = fire_check_ctrl;
aim_arrow.x = x_fire 
aim_arrow.y = y_fire
aim_arrow.image_angle = aim_direction;

// Use fire_pressed_start to change the aim style.
if (fire_released_ctrl) {
  var class = -1;
  if(global.mage_level == mage_power.ice) {
    with (instance_create(x_fire, y_fire, obj_spark)) {
      direction = aim_direction;
      speed = max_speed;
    }
  } else if(global.mage_level == mage_power.fire) {
    with (instance_create(x_fire, y_fire, obj_fireball)) {
      direction = aim_direction;
      speed = max_speed;
    }
  }
}

// Kill the mage when touching something dangerous.
if (place_meeting(x + 1, y + 1, obj_dangerous) ||
    place_meeting(x - 1, y - 1, obj_dangerous)) {
  do_die = 1;
}
// Die when falling down from the room.
if (y &gt; room_height + 64) {
  do_die = 1;
}

if (do_die) {
  instance_create(x, y, obj_explode);
  instance_destroy();
  // Request player respawn.
  with(obj_spawn) {
    state = spawn_state.do_respawn;
    break;
  }
}

// Create a trail for debugging.
var point = instance_create(x, y, obj_dot);
if(jump_held_ctrl) {
  point.image_blend = c_red
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Get user inputs.
jump_pressed_ctrl = keyboard_check_pressed(vk_space);
jump_held_ctrl = keyboard_check(vk_space);
fire_pressed_ctrl = keyboard_check_pressed(vk_control);
fire_check_ctrl = keyboard_check(vk_control);
fire_released_ctrl = keyboard_check_released(vk_control);
x_ctrl = keyboard_check(vk_right) - keyboard_check(vk_left);
y_ctrl = keyboard_check(vk_down) - keyboard_check(vk_up);

// Apply input override for test only.
if (input_override_script) {
  script_execute(input_override_script);
}

// Display debug information. To be removed.
if(fire_pressed_ctrl) fire_frame_count = 0;
if(fire_check_ctrl) fire_frame_count += 1;
if(fire_released_ctrl) show_debug_message("fire duration " + string(fire_frame_count))


// Tells if the object lies on something solid or not.
is_standing = place_meeting(floor(x), floor(y) + 1, obj_solid)
// The mage walks horizontaly except when aiming.
var target_xs = x_ctrl * walk_speed;
if(fire_check_ctrl) {
  if(is_standing) { // When aiming and on the ground stop moving.
    target_xs = 0; // Inhibit walk.
  } // When aiming and in the air keep moving until reaching the ground.
} else {
  // When trying to move in the opposite direction of the current movement.
  var accel = IIF(xs * (target_xs - xs) &lt; 0, brake_accel, walk_accel);
  // Apply the acceleration toward the intended direction.
  xs = Approach(xs, target_xs, accel);
}

// ## Jump
// Its possible to press the jumb ctrl a few frames before reaching a platform.
// Keeping hte jump pressed for a few frames makes the character jump higher.
if (jump_pressed_ctrl) { jump_ctrl_countdown = jump_ctrl_permissiveness; }
if (!jump_held_ctrl) { jump_ctrl_countdown = 0; ys = max(ys, -jump_released_speed);}
if (jump_ctrl_countdown &amp;&amp; is_standing) {
  jump_ctrl_countdown = 0;
  ys = -jump_initial_speed;
}
jump_ctrl_countdown = max(0, jump_ctrl_countdown - 1);

if(global.mage_level == mage_power.wind &amp;&amp; keyboard_check(fire_check_ctrl)) {  
  ys -= 0.18;
}

//show_debug_message(string(ys))

// Push a block when the mage is in contact with it.
var x_push = xs; // Horizontal displacement transmited to a pusheable object.
if xs != 0 &amp;&amp; place_meeting(floor(xx + sign(x_push)), floor(yy), obj_icecube) { 
  // A block is being pushed.
  xs = sign(x_ctrl) * push_speed;
  var block = instance_place(floor(xx + sign(x_push)), floor(yy), obj_icecube);
  block.xs = xs; // Set the horizontal speed of the block.
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with(obj_spawn) {
  x = other.x; y = other.y;
  exit;
}
// If none exist create one.
instance_create(x, y, obj_spawn)


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
