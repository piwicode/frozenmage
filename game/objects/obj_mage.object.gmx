<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sp_mage_32</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>400</depth>
  <persistent>0</persistent>
  <parentName>obj_entity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_move_init()

// Input variables have to be defined so that an instance 
// create by an alarm can run the end setp without the begin step.
jump_pressed_ctrl = 0;
jump_held_ctrl = 0;
fire_pressed_ctrl = 0;
fire_check_ctrl = 0;
fire_released_ctrl = 0;
x_ctrl = 0;
y_ctrl = 0;

// state
is_walking = false;
previous_is_walking = false;
walking_sound = 0;

walk_speed = 2.5  // maximum horizontal speed reached when walking.
walk_accel = 0.15;  // time it takes to reach the 0 speed.
brake_accel = 0.25;  // time it takes to reach the max speed.
push_speed = 1; // constant horizontal speed, when pushing a block.
jump_initial_speed = 4.7 ; // pixel per frame.
jump_released_speed = 2; // pixel per frame.
jump_ctrl_permissiveness = 20; // Number of frames the jump initial key press can trigger the jump action.
jump_ctrl_countdown = 0;  // frames. 

if(string_copy(room_get_name(room),0, 6) == "rm_niv" or true ) {
  walk_speed = 2.5  // maximum horizontal speed reached when walking.
  walk_accel = 0.15;  // time it takes to reach the 0 speed.
  brake_accel = 0.25;  // time it takes to reach the max speed.
  push_speed = 1; // constant horizontal speed, when pushing a block.
  jump_initial_speed = 4.3 ; // pixel per frame.
  jump_released_speed = 2; // pixel per frame.
  jump_ctrl_permissiveness = 20; // Number of frames the jump initial key press can trigger the jump action.
  jump_ctrl_countdown = 0;  // frames. 
}

var step_length_in_px = 90;
const_image_speed_walk = 14 / (step_length_in_px * 2) * walk_speed // frame per tick

image_speed = 0; // No animation by default.

// Override user inputs for test purpose. Set the following vars with instance
// initialization script.
// Name of a script with no argument executed on the mage after input handling.
input_override_script = false; // Set to true in conjunction



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>audio_stop_sound(walking_sound);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Detect collisions with walls

scr_move();

// Horizontal flip the sprite according to the command.
if (x_ctrl != 0) {
  image_xscale = x_ctrl;
}
// Play the walk animation only when the mage is moving horizontally.
image_speed = const_image_speed_walk * (xs != 0);

// -y_ctrl because vertical axis is inverted between atan and the screen.
// use image_scale to remember the current facing position. 
var x_fire = (bbox_right + bbox_left) * .5 + abs(bbox_right - bbox_left) * .25 * image_xscale;
var y_fire = bbox_top * .75 + bbox_bottom * .25;

aim_direction = radtodeg(arctan2(-y_ctrl *.5, image_xscale));

// Use fire_pressed_start to change the aim style.
if (fire_pressed_ctrl) {
  audio_play_sound(snd_spell, 50, false);
  if(global.mage_level == mage_power.ice) {
    with (instance_create(x_fire, y_fire, obj_spark)) {
      direction = other.aim_direction;
      image_angle = other.aim_direction
      speed = max_speed;
    }
  } else if(global.mage_level == mage_power.fire) {
    with (instance_create(x_fire, y_fire, obj_fireball)) {
      direction = aim_direction;
      image_angle = aim_direction
      speed = max_speed;
    }
  }
}


// Kill the mage when touching something dangerous.
if (place_meeting(x + 1, y + 1, obj_dangerous) ||
    place_meeting(x - 1, y - 1, obj_dangerous)) {
  do_die = 1;
}
// Die when falling down from the room.
if (y &gt; room_height + 64) {
  do_die = 1;
}

if (do_die) {
  scr_emit_magic_burst(40, 40);  
  instance_destroy();
  // Request player respawn.
  with(obj_spawn) {
    state = spawn_state.do_respawn;
    break;
  }

}

// Create a trail for debugging.
var point = instance_create(x, y, obj_dot);
if(jump_held_ctrl) {
  point.image_blend = c_red
}

// Sound effects
previous_is_walking = is_walking;
is_walking = x_ctrl != 0 and xs != 0;
if(is_walking != previous_is_walking) {
  if(is_walking) {
     audio_stop_sound(walking_sound);
     walking_sound = audio_play_sound(snd_walk, 30, true);
     audio_sound_gain(walking_sound, 0, 0);
     audio_sound_gain(walking_sound, 1, 700);
  } else {
     audio_stop_sound(walking_sound);
  }
}

// Sound of foot hitting the ground after a jump.
// The volume of the sound depends on the intensity of the impact.
if (delta_ys &gt; 1) {
  // Vertical speed corresponding to the maximum sound intensity.
  var delta_ys_max_volume = 8;  
  var volume = clamp(delta_ys / delta_ys_max_volume, 0, 1);
  audio_sound_gain(audio_play_sound(snd_foot, 50, false), volume, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Get user inputs.

jump_pressed_ctrl = scr_input_pressed(vk_space, gp_face1);
jump_held_ctrl = scr_input_held(vk_space, gp_face1);
fire_pressed_ctrl = scr_input_pressed(vk_control, gp_face3);
fire_check_ctrl = scr_input_held(vk_control, gp_face3);
fire_released_ctrl = scr_input_released(vk_control, gp_face3);
x_ctrl = src_input_axis(vk_right, vk_left, gp_padr, gp_padl, gp_axislh);
y_ctrl = src_input_axis(vk_down, vk_up, gp_padd, gp_padu, gp_axislv);

// Apply input override for test only.
if (input_override_script) {
  script_execute(input_override_script);
}

// Tells if the object lies on something solid or not.
is_standing = place_meeting(floor(x), floor(y) + 1, obj_solid)

// The mage walks horizontaly except when aiming.
var target_xs = x_ctrl * walk_speed;
if(fire_check_ctrl) {
  if(is_standing) { // When aiming and on the ground stop moving.
    target_xs = 0; // Inhibit walk.
  } // When aiming and in the air keep moving until reaching the ground.
} else {
  // When trying to move in the opposite direction of the current movement.
  var accel = IIF(xs * (target_xs - xs) &lt; 0, brake_accel, walk_accel);
  // Apply the acceleration toward the intended direction.
  xs = Approach(xs, target_xs, accel);
}

// ## Jump
// It's possible to press the jumb ctrl a few frames before reaching a platform.
// Keeping hte jump pressed for a few frames makes the character jump higher.
if (jump_pressed_ctrl) { jump_ctrl_countdown = jump_ctrl_permissiveness; }
if (!jump_held_ctrl) { jump_ctrl_countdown = 0; ys = max(ys, -jump_released_speed);}
if (jump_ctrl_countdown &amp;&amp; is_standing) {
  jump_ctrl_countdown = 0;
  ys = -jump_initial_speed;
  audio_play_sound(snd_jump, 30, false);
}

jump_ctrl_countdown = max(0, jump_ctrl_countdown - 1);

if(global.mage_level == mage_power.wind &amp;&amp; keyboard_check(fire_check_ctrl)) {  
  ys -= 0.18;
}

// Move the viewport up and down according to controls.
view_yview[0] += y_ctrl * 2

// Push a block when the mage is in contact with it.
var x_push = xs; // Horizontal displacement transmited to a pusheable object.
if xs != 0 &amp;&amp; place_meeting(floor(xx + sign(x_push)), floor(yy), obj_par_block) { 
  // A block is being pushed.
  xs = sign(x_ctrl) * push_speed;
  var block = instance_place(floor(xx + sign(x_push)), floor(yy), obj_par_block);
  block.xs = xs; // Set the horizontal speed of the block.
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>audio_stop_sound(walking_sound);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with(obj_spawn) {
  x = other.x; y = other.y;
  exit;
}
// If none exist create one.
instance_create(x, y, obj_spawn)


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
